# ============================================
# ソートアルゴリズムのサンプルコード
# ============================================

# ============================================
# 1. バブルソート（Bubble Sort）
# ============================================
# 最もシンプルで理解しやすいソートアルゴリズム
# 時間計算量: O(n²)

A ← [ 7, 3, 9, 4, 6 ]
N ← LENGTH(A)

FOR i ← 1 TO N - 1
  FOR j ← 1 TO N - i
    IF A[j] > A[j + 1] THEN
      TEMP ← A[j]
      A[j] ← A[j + 1]
      A[j + 1] ← TEMP
    ENDIF
  ENDFOR
ENDFOR

FOR k ← 1 TO N
  PRINT A[k]
ENDFOR

# ============================================
# 2. 選択ソート（Selection Sort）
# ============================================
# 最小値を見つけて先頭に移動する
# 時間計算量: O(n²)

A ← [ 7, 3, 9, 4, 6 ]
N ← LENGTH(A)

FOR i ← 1 TO N - 1
  MIN_POS ← i
  FOR j ← i + 1 TO N
    IF A[j] < A[MIN_POS] THEN
      MIN_POS ← j
    ENDIF
  ENDFOR
  IF MIN_POS != i THEN
    TEMP ← A[i]
    A[i] ← A[MIN_POS]
    A[MIN_POS] ← TEMP
  ENDIF
ENDFOR

FOR k ← 1 TO N
  PRINT A[k]
ENDFOR

# ============================================
# 3. 挿入ソート（Insertion Sort）
# ============================================
# カードを並べ替えるように、要素を適切な位置に挿入
# 時間計算量: O(n²) だが、実用的には高速

A ← [ 7, 3, 9, 4, 6 ]
N ← LENGTH(A)

FOR i ← 2 TO N
  KEY ← A[i]
  j ← i - 1
  WHILE j >= 1 AND A[j] > KEY
    A[j + 1] ← A[j]
    j ← j - 1
  ENDWHILE
  A[j + 1] ← KEY
ENDFOR

FOR k ← 1 TO N
  PRINT A[k]
ENDFOR

# ============================================
# 4. クイックソート（Quick Sort）- Lomuto方式
# ============================================
# 分割統治法を使った高速なソート
# 時間計算量: 平均 O(n log n)、最悪 O(n²)
# 注意: このアプリでは動作しますが、無限ループの可能性があるため注意が必要です

A ← [ 7, 3, 9, 4, 6 ]
N ← LENGTH(A)

CALL QuickSort(1, N)

FOR k ← 1 TO N
  PRINT A[k]
ENDFOR

PROCEDURE QuickSort(left, right)
  IF left >= right THEN
    RETURN
  ENDIF

  # Lomuto partition scheme
  pivot ← A[right]
  i ← left

  FOR j ← left TO right - 1
    IF A[j] <= pivot THEN
      SWAP_TEMP ← A[i]
      A[i] ← A[j]
      A[j] ← SWAP_TEMP
      i ← i + 1
    ENDIF
  ENDFOR

  SWAP_TEMP ← A[i]
  A[i] ← A[right]
  A[right] ← SWAP_TEMP

  # 再帰呼び出し（境界チェック付き）
  IF i - 1 > left THEN
    CALL QuickSort(left, i - 1)
  ENDIF
  IF i + 1 < right THEN
    CALL QuickSort(i + 1, right)
  ENDIF
ENDPROCEDURE

# ============================================
# 5. マージソート（Merge Sort）
# ============================================
# 分割統治法を使った安定ソート
# 時間計算量: O(n log n)
# 注意: このアプリでは動作しますが、作業用配列が必要です

A ← [ 7, 3, 9, 4, 6 ]
N ← LENGTH(A)

# 作業用配列を初期化（配列は動的に作成される）
TEMP ← [ 0, 0, 0, 0, 0, 0 ]

CALL MergeSort(1, N)

FOR k ← 1 TO N
  PRINT A[k]
ENDFOR

PROCEDURE MergeSort(left, right)
  # ベースケース: 要素が1つ以下の場合は終了
  IF left >= right THEN
    RETURN
  ENDIF

  # mid の計算（整数除算で中央値を求める）
  # 例: left=1, right=5 → mid=3
  #     left=1, right=4 → mid=2
  mid ← (left + right) // 2
  
  # 左半分をソート（left < mid が保証されている）
  CALL MergeSort(left, mid)
  
  # 右半分をソート（mid + 1 <= right が保証されている）
  CALL MergeSort(mid + 1, right)
  
  # マージ処理
  CALL Merge(left, mid, right)
ENDPROCEDURE

PROCEDURE Merge(left, mid, right)
  i ← left
  j ← mid + 1
  k ← left

  WHILE i <= mid AND j <= right
    IF A[i] <= A[j] THEN
      TEMP[k] ← A[i]
      i ← i + 1
    ELSE
      TEMP[k] ← A[j]
      j ← j + 1
    ENDIF
    k ← k + 1
  ENDWHILE

  WHILE i <= mid
    TEMP[k] ← A[i]
    i ← i + 1
    k ← k + 1
  ENDWHILE

  WHILE j <= right
    TEMP[k] ← A[j]
    j ← j + 1
    k ← k + 1
  ENDWHILE

  FOR m ← left TO right
    A[m] ← TEMP[m]
  ENDFOR
ENDPROCEDURE

# ============================================
# 6. 降順ソート（Selection Sort使用）
# ============================================
# 大きい順に並べ替える

A ← [ 7, 3, 9, 4, 6 ]
N ← LENGTH(A)

FOR i ← 1 TO N - 1
  MAX_POS ← i
  FOR j ← i + 1 TO N
    IF A[j] > A[MAX_POS] THEN
      MAX_POS ← j
    ENDIF
  ENDFOR
  IF MAX_POS ≠ i THEN
    TEMP ← A[i]
    A[i] ← A[MAX_POS]
    A[MAX_POS] ← TEMP
  ENDIF
ENDFOR

FOR k ← 1 TO N
  PRINT A[k]
ENDFOR
